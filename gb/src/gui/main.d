/*
	Generated by Entice Designer 0.8.1
	Entice Designer written by Christopher E. Miller
	www.dprogramming.com/entice.php
*/

module gui.main;

private import gui.about;

private import gui.gdebug.main;

private import dfl.all, dfl.internal.winapi;
private import std.stdio, std.thread, std.string, std.file;
private import gameboy.z80, gameboy.joypad;

extern(Windows) {
	void Sleep(u32);
	u32 GetTickCount();
	u32 QueryPerformanceCounter(u64 *lpPerformanceCount);
	u32 QueryPerformanceFrequency(u64 *lpFrequency);
}

class String {
	char[] value;
	this(char[] value) { this.value = value; }
	override char[] toString() { return value; }
}

class MainForm: dfl.form.Form, IMessageFilter, GameboyHostSystem {
	// Do not modify or move this block of variables.
	//~Entice Designer variables begin here.
	dfl.picturebox.PictureBox pictureBox1;
	//~Entice Designer variables end here.
	
	Size window_m;

	GameBoy gb;

	static f96 qpfreq = 0;

	static this() {
		u64 qpfreqv;
		QueryPerformanceFrequency(&qpfreqv);
		qpfreq = cast(f96)qpfreqv;		
	}

	void UpdateFPS() {
		static f96 fps = 59.73, fps_back = 59.73; static u64 start = 0, current = 0, count = 0;

		QueryPerformanceCounter(&current);

		if (start != 0) fps = qpfreq / (cast(f96)(current - start));

		start = current;

		count++;

		if (count >= 15) {
			this.text = format("GameBoy %4.1f fps", cast(f32)fps_back);
			count = 0;
		}

		fps_back = (cast(f96)fps + (cast(f96)fps_back * cast(f96)120)) / cast(f96)(120 + 1);
	}

	void DelayVBlank() {
		f96 sec;
		static u64 start = 0, current = 0;
		static f96 payload = 0.0f;

		if (start == 0) QueryPerformanceCounter(&start);

		while (true) {
			QueryPerformanceCounter(&current);
			sec = cast(f96)(current - start) / cast(f96)qpfreq;
			//printf("%f - %f\r", cast(float)sec, cast(float)(1.0f / 59.73f));
			if (sec - payload >= 1.0f / 59.73f) {
				payload = (sec - payload) - 1.0f / 59.73f;
				break;
			}			
		}	

		Sleep(10);	

		start = current;
	}

	u16[] screenData;
	HDC hdc;
	BITMAPINFO bi;	

	void DrawScreenData() {
		this.hdc = pictureBox1.createGraphics().handle;
		StretchDIBits(hdc, 0, 0, pictureBox1.width, pictureBox1.height, 0, 0, 160, 144, screenData.ptr, &bi, 0, SRCCOPY);
	}

	/*void onPaint(Control c, PaintEventArgs pea) {
		DrawScreenData();
	}*/
	
	int type;
	u8* LCDSCR;
	bool mustUpdate = true;
	
	void UpdateScreen(int type, u8* LCDSCR) {
		this.type = type;
		this.LCDSCR = LCDSCR;
		mustUpdate = true;
		UpdateFPS();
		DelayVBlank();
	}

	void UpdateScreen2() {
		if (!mustUpdate || !LCDSCR) return;
		
		mustUpdate = false;		
		
		switch (type) {
			case 0: default: case 1: {
				u16 RGB16(int r, int g, int b) {
					return
						(((b >> 3) & 0b11111) <<  0) |
						(((g >> 3) & 0b11111) <<  5) |
						(((r >> 3) & 0b11111) << 10) |
					0;
				}
				u16[4] palette;
				palette[0] = RGB16(0x9C, 0xB9, 0x16);
				palette[1] = RGB16(0x8C, 0xAA, 0x14);
				palette[2] = RGB16(0x30, 0x64, 0x30);
				palette[3] = RGB16(0x10, 0x3F, 0x10);

				screenData.length = 144 * 160;
				for (int y = 0, n1 = 0, n2 = 0; y < 144; y++) {
					for (int x = 0; x < 160; x += 4, n1++) {
						u8 b = LCDSCR[n1];
						screenData[n2++] = palette[(b >> 0) & 0b11];
						screenData[n2++] = palette[(b >> 2) & 0b11];
						screenData[n2++] = palette[(b >> 4) & 0b11];
						screenData[n2++] = palette[(b >> 6) & 0b11];
					}
				}

				DrawScreenData();
			} break;
		}
	}

	void attach(GameBoy gb) {
		this.gb = gb;
	}

	void updateClientSize(int magnifier = 2) {
		Size size = this.clientSize();
		
		this.setClientSizeCore(
			size.width  + (160 * magnifier - pictureBox1.width),
			size.height + (144 * magnifier - pictureBox1.height)
		);
		
		this.centerToScreen();
		//this.refresh();
	}
	
	void doTick(Timer t, EventArgs ea) {
		UpdateScreen2();
	}
	
	Timer t;

	this() {
		t = new Timer();
		t.interval = 1;
		t.tick ~= &doTick;
		t.start();
	
		width = 0;
		height = 0;
		window_m = Size(width, height);
		
		initializeMainForm();
		initializeKeyTranslator();

		addShortcut(Keys.F1, &optionSaveState);
		addShortcut(Keys.F2, &optionSaveState);
		addShortcut(Keys.F3, &optionSaveState);
		addShortcut(Keys.F4, &optionSaveState);

		addShortcut(Keys.F5, &optionLoadState);
		addShortcut(Keys.F6, &optionLoadState);
		addShortcut(Keys.F7, &optionLoadState);
		addShortcut(Keys.F8, &optionLoadState);

		addShortcut(Keys.ALT | Keys.D1, &optionSizeChange);
		addShortcut(Keys.ALT | Keys.D2, &optionSizeChange);
		addShortcut(Keys.ALT | Keys.D3, &optionSizeChange);
		addShortcut(Keys.ALT | Keys.D4, &optionSizeChange);

		with (bi.bmiHeader) {
			biSize      = 40;
			biWidth     = 160;
			biHeight    = -144;
			biPlanes    = 1;
			biBitCount  = 16;
			biSizeImage = 46080;
		}

		MenuItem cMenuItem(char[] text, MenuItem[] mil = null, void delegate(MenuItem, EventArgs) click = null, char[] name = "") {
			MenuItem mi = new MenuItem(text, mil);
			if (click) mi.click ~= click;
			mi.tag = new String(name);
			return mi;
		}

		this.menu = new MainMenu([
			cMenuItem("&Archivo", [
				cMenuItem("&Abrir ROM...", null, &optionOpenRom),
				cMenuItem("-"),
				cMenuItem("&Guardar estado", [
					cMenuItem("Estado 1\tF1", null, &optionSaveState, "s1"),
					cMenuItem("Estado 2\tF2", null, &optionSaveState, "s2"),
					cMenuItem("Estado 3\tF3", null, &optionSaveState, "s3"),
					cMenuItem("Estado 4\tF4", null, &optionSaveState, "s4")
				]),
				new MenuItem("&Cargar estado", [
					cMenuItem("Estado 1\tF5", null, &optionLoadState, "l1"),
					cMenuItem("Estado 2\tF6", null, &optionLoadState, "l2"),
					cMenuItem("Estado 3\tF7", null, &optionLoadState, "l3"),
					cMenuItem("Estado 4\tF8", null, &optionLoadState, "l4")
				]),
				cMenuItem("-"),
				cMenuItem("&Salir", null, &optionExit)
			]),
			cMenuItem("&Emulación", [
				cMenuItem("&Reiniciar", null, &optionReset),
				cMenuItem("&Depurador", null, &optionDebug),
				new MenuItem("&Vista", [
					cMenuItem("1x\tAlt+1", null, &optionSizeChange, "1"),
					cMenuItem("2x\tAlt+2", null, &optionSizeChange, "2"),
					cMenuItem("3x\tAlt+3", null, &optionSizeChange, "3"),
					cMenuItem("4x\tAlt+4", null, &optionSizeChange, "4")
				])
			]),
			cMenuItem("&Ayuda", [
				cMenuItem("&Sobre...", null, &optionShowAbout)
			])
		]);

		this.icon = Application.resources.getIcon(101);
		updateClientSize(2);
	}
	
	char[] stateFile(int id) { return format("states\\%s.%02d.snap", gb.romName, id); }

	void saveState(char[] name) { gb.save(name); }
	void saveState(int id) { saveState(stateFile(id)); }

	void loadState(char[] name) { gb.load(name); }
	void loadState(int id) { loadState(stateFile(id)); }

	private void optionSizeChange(MenuItem mi, EventArgs ea) {
		updateClientSize(std.conv.toInt(mi.tag.toString));
	}
	
	private void optionShowAbout(MenuItem mi, EventArgs ea) {
		(new About()).showDialog();
	}

	private void optionSizeChange(Object sender, FormShortcutEventArgs ea) {
		Keys k = ea.shortcut & ~Keys.ALT;
		updateClientSize(k - Keys.D0);
	}

	private void optionSaveState(Object sender, FormShortcutEventArgs ea) {
		if (ea.shortcut >= Keys.F1 && ea.shortcut <= Keys.F4) saveState(ea.shortcut - Keys.F1 + 1);
	}

	private void optionLoadState(Object sender, FormShortcutEventArgs ea) {
		if (ea.shortcut >= Keys.F5 && ea.shortcut <= Keys.F8) loadState(ea.shortcut - Keys.F5 + 1);
	}

	void optionSaveState(MenuItem mi, EventArgs ea) {
		char[] s = mi.tag.toString; if (s.length < 2 || s[0] != 's') return;
		int v = s[1] - '0'; if (v >= 1 && v <= 4) saveState(v);
	}

	void optionLoadState(MenuItem mi, EventArgs ea) {
		char[] s = mi.tag.toString; if (s.length < 2 || s[0] != 'l') return;
		int v = s[1] - '0'; if (v >= 1 && v <= 4) loadState(v);
	}

	void optionReset(MenuItem mi, EventArgs ea) {
		gb.stop = true;
		while (!gb.stopped) Sleep(1);
		gb.init();
		gb.stop = false;
	}

	void optionDebug(MenuItem mi, EventArgs ea) {
		(new DebugForm()).show();
	}

	void optionOpenRom(MenuItem mi, EventArgs ea) {
		gbt.pause();
		OpenFileDialog ofd = new OpenFileDialog;
		ofd.filter = "GameBoy files (*.gb)|*.gb";
		ofd.initialDirectory = Application.startupPath ~ "\\roms";
		if (ofd.showDialog() == DialogResult.OK) {
			gbt.resume();

			chdir(Application.startupPath);

			gb.unloadRom();

			gb.stop = true;
			while (!gb.stopped) Sleep(1);

			gb.loadRom(ofd.fileName);
			gb.init();

			gb.stop = false;
		} else {
			gbt.resume();
		}
	}

	void optionExit(MenuItem mi, EventArgs ea) {
		Application.exit();
	}


	private void initializeMainForm() {
		// Do not manually edit this block of code.
		//~Entice Designer 0.8.2.1 code begins here.
		//~DFL Form
		maximizeBox = false;
		startPosition = dfl.form.FormStartPosition.CENTER_SCREEN;
		text = "GameBoy";
		clientSize = dfl.drawing.Size(292, 271);
		//~DFL dfl.picturebox.PictureBox=pictureBox1
		pictureBox1 = new dfl.picturebox.PictureBox();
		pictureBox1.name = "pictureBox1";
		pictureBox1.dock = dfl.control.DockStyle.FILL;
		pictureBox1.bounds = dfl.base.Rect(0, 0, 292, 271);
		pictureBox1.parent = this;
		//~Entice Designer 0.8.2.1 code ends here.
	}

	JoyPAD.Key[uint] keyTranslator;

	void setKey(Keys skey, JoyPAD.Key gkey) {
		keyTranslator[cast(uint)skey] = gkey;
	}

	void initializeKeyTranslator() {
		setKey(Keys.UP   , JoyPAD.Key.UP);
		setKey(Keys.LEFT , JoyPAD.Key.LEFT);
		setKey(Keys.DOWN , JoyPAD.Key.DOWN);
		setKey(Keys.RIGHT, JoyPAD.Key.RIGHT);

		setKey(Keys.Z    , JoyPAD.Key.A);
		setKey(Keys.X    , JoyPAD.Key.B);
		setKey(Keys.SPACE, JoyPAD.Key.SELECT);
		setKey(Keys.ENTER, JoyPAD.Key.START);
	}

	bool preFilterMessage(inout Message m) {
		//printf("%d %08X\r", m.msg, m.hWnd);
		if (this.pictureBox1.handle != m.hWnd && this.handle != m.hWnd) return false;
		switch (m.msg) {
			case 256: // WM_KEYDOWN
			case 257: // WM_KEYUP
				if (m.msg == 257) {
					if (m.wParam == 27) Application.exit();
				}

				if (gb && gb.pad && m.wParam in keyTranslator) {
					m.wParam &= ~Keys.ALT;
					m.wParam &= ~Keys.CONTROL;
					m.wParam &= ~Keys.SHIFT;
					
					JoyPAD.Key key = keyTranslator[m.wParam];
					if (m.msg == 256) gb.pad.Press(key); else gb.pad.Release(key);					
				}				
				return true;
			break;
			default: break;
		}
		return false;
	}

}

MainForm mainForm;
GameboyThread gbt;

class GameboyThread : Thread {
	GameBoy gb;

	override int run() {
		gb = new GameBoy(mainForm);

		//gb.loadRom("ROMS\\TETRIS.GB");
		gb.loadRom("ROMS\\MARIO.GB");
		while (true) {
			gb.init();

			try {
				gb.interpret();
			} catch (Object o) {
				msgBox(o.toString(), "Emulation Error", MsgBoxButtons.OK, MsgBoxIcon.EXCLAMATION);
			}
		}

		return 0;
	}
}


int main()
{
	int result = 0;

	try {
		mainForm = new MainForm();

		gbt = new GameboyThread();
		gbt.setPriority(std.thread.Thread.PRIORITY.IDLE);
		gbt.start();
		
		
		Application.addMessageFilter(mainForm);
		Application.run(mainForm);

	} catch(Object o) {
		msgBox(o.toString(), "Fatal Error", MsgBoxButtons.OK, MsgBoxIcon.ERROR);

		result = 1;
	}

	return result;
}

