/*
	Generated by Entice Designer 0.8.1
	Entice Designer written by Christopher E. Miller
	www.dprogramming.com/entice.php
*/

private import dfl.all, dfl.internal.winapi;
private import std.stdio, std.thread, std.string, std.file;
private import gameboy.z80, gameboy.joypad;

extern(Windows) {
	void Sleep(u32);
	u32 GetTickCount();
	u32 QueryPerformanceCounter(u64 *lpPerformanceCount);
	u32 QueryPerformanceFrequency(u64 *lpFrequency);
}

class String {
	char[] value;	
	this(char[] value) { this.value = value; }
	override char[] toString() { return value; }
}

class MainForm: dfl.form.Form, IMessageFilter, GameboyHostSystem {
	// Do not modify or move this block of variables.
	//~Entice Designer variables begin here.
	dfl.picturebox.PictureBox pictureBox1;
	//~Entice Designer variables end here.
	
	GameBoy gb;
	
	static f96 qpfreq = 0;
	
	static this() {
		u64 qpfreqv;
		QueryPerformanceFrequency(&qpfreqv);
		qpfreq = cast(f96)qpfreqv;			
	}
	
	void UpdateFPS() {
		static f96 fps = 59.73, fps_back = 59.73; static u64 start = 0, current = 0, count = 0;		

		QueryPerformanceCounter(&current);

		if (start != 0) fps = qpfreq / (cast(f96)(current - start));

		start = current;

		count++;

		if (count >= 15) {
			this.text = format("GameBoy %4.1f fps", cast(f32)fps_back);
			count = 0;
		}

		fps_back = (cast(f96)fps + (cast(f96)fps_back * cast(f96)120)) / cast(f96)(120 + 1);		
	}
	
	void DelayVBlank() {
		f96 sec;
		static u64 start = 0, current = 0;
		static f96 payload = 0.0f;

		if (start == 0) QueryPerformanceCounter(&start);

		while (true) {
			QueryPerformanceCounter(&current);
			sec = cast(f96)(current - start) / cast(f96)qpfreq;
			//printf("%f - %f\r", cast(float)sec, cast(float)(1.0f / 59.73f));
			if (sec - payload >= 1.0f / 59.73f) {
				payload = (sec - payload) - 1.0f / 59.73f;
				break;
			}
		}

		start = current;
	}
	
	u16[] screenData;
	HDC hdc;
	BITMAPINFO bi;
	
	void DrawScreenData() {
		this.hdc = pictureBox1.createGraphics().handle;
		StretchDIBits(hdc, 0, 0, pictureBox1.width, pictureBox1.height, 0, 0, 160, 144, screenData.ptr, &bi, 0, SRCCOPY);
	}
	
	/*void onPaint(Control c, PaintEventArgs pea) {
		DrawScreenData();
	}*/
	
	void UpdateScreen(int type, u8* LCDSCR) {
		UpdateFPS();
		{			
			switch (type) {
				case 0: default: case 1: {
					u16 RGB16(int r, int g, int b) {
						return
							(((b >> 3) & 0b11111) <<  0) |
							(((g >> 3) & 0b11111) <<  5) |
							(((r >> 3) & 0b11111) << 10) |
						0;
					}
					u16[4] palette;
					palette[0] = RGB16(0x9C, 0xB9, 0x16);
					palette[1] = RGB16(0x8C, 0xAA, 0x14);
					palette[2] = RGB16(0x30, 0x64, 0x30);
					palette[3] = RGB16(0x10, 0x3F, 0x10);
					
					screenData.length = 144 * 160;
					for (int y = 0, n1 = 0, n2 = 0; y < 144; y++) {
						for (int x = 0; x < 160; x += 4, n1++) {
							u8 b = LCDSCR[n1];
							screenData[n2++] = palette[(b >> 0) & 0b11];
							screenData[n2++] = palette[(b >> 2) & 0b11];
							screenData[n2++] = palette[(b >> 4) & 0b11];
							screenData[n2++] = palette[(b >> 6) & 0b11];
						}
					}				
					
					DrawScreenData();
				} break;
			}
		}
		DelayVBlank();
	}

	void attach(GameBoy gb) {
		this.gb = gb;
	}
	
	void updateClientSize() {
		this.setClientSizeCore(
			this.width  + (320 - pictureBox1.width),
			this.height + (288 - pictureBox1.height)
		);
		
		this.centerToScreen();			
		this.refresh();
	}

	this() {
		initializeMainForm();
		initializeKeyTranslator();

		updateClientSize();
		
		addShortcut(Keys.F1, &optionSaveState);
		addShortcut(Keys.F2, &optionSaveState);
		addShortcut(Keys.F3, &optionSaveState);
		addShortcut(Keys.F4, &optionSaveState);

		addShortcut(Keys.F5, &optionLoadState);
		addShortcut(Keys.F6, &optionLoadState);
		addShortcut(Keys.F7, &optionLoadState);
		addShortcut(Keys.F8, &optionLoadState);
			
		with (bi.bmiHeader) {
			biSize      = 40;
			biWidth     = 160;
			biHeight    = -144;
			biPlanes    = 1;
			biBitCount  = 16;
			biSizeImage = 46080;
		}
		
		MenuItem cMenuItem(char[] text, MenuItem[] mil = null, void delegate(MenuItem, EventArgs) click = null, char[] name = "") {
			MenuItem mi = new MenuItem(text, mil);
			if (click) mi.click ~= click;
			mi.tag = new String(name);
			return mi;
		}

		this.menu = new MainMenu([
			cMenuItem("&Archivo", [
				cMenuItem("&Abrir ROM...", null, &optionOpenRom),
				cMenuItem("-"),
				cMenuItem("&Guardar estado", [
					cMenuItem("Estado 1\tF1", null, &optionSaveState, "s1"),
					cMenuItem("Estado 2\tF2", null, &optionSaveState, "s2"),
					cMenuItem("Estado 3\tF3", null, &optionSaveState, "s3"),
					cMenuItem("Estado 4\tF4", null, &optionSaveState, "s4")
				]),
				new MenuItem("&Cargar estado", [
					cMenuItem("Estado 1\tF5", null, &optionLoadState, "l1"),
					cMenuItem("Estado 2\tF6", null, &optionLoadState, "l2"),
					cMenuItem("Estado 3\tF7", null, &optionLoadState, "l3"),
					cMenuItem("Estado 4\tF8", null, &optionLoadState, "l4")
				]),
				cMenuItem("-"),
				cMenuItem("&Salir", null, &optionExit)
			]),
			cMenuItem("&Emulación", [
				cMenuItem("&Reiniciar", null, &optionReset)
			]),
			cMenuItem("&Ayuda", [
				cMenuItem("&Sobre...")
			])			
		]);
		
		this.icon = Application.resources.getIcon(101);		
	}
	
	void saveState(char[] name) { gb.save(name); }
	void saveState(int id) { saveState(format("dump.%d", id)); }

	void loadState(char[] name) { gb.load(name); }
	void loadState(int id) { loadState(format("dump.%d", id)); }

	
	private void optionSaveState(Object sender, FormShortcutEventArgs ea) {
		if (ea.shortcut >= Keys.F1 && ea.shortcut <= Keys.F4) saveState(ea.shortcut - Keys.F1 + 1);
	}	

	private void optionLoadState(Object sender, FormShortcutEventArgs ea) {
		if (ea.shortcut >= Keys.F5 && ea.shortcut <= Keys.F8) loadState(ea.shortcut - Keys.F5 + 1);
	}	
	
	void optionSaveState(MenuItem mi, EventArgs ea) {
		char[] s = mi.tag.toString; if (s.length < 2 || s[0] != 's') return;
		int v = s[1] - '0'; if (v >= 1 && v <= 4) saveState(v);
	}
	
	void optionLoadState(MenuItem mi, EventArgs ea) {
		char[] s = mi.tag.toString; if (s.length < 2 || s[0] != 'l') return;		
		int v = s[1] - '0'; if (v >= 1 && v <= 4) loadState(v);
	}

	void optionReset(MenuItem mi, EventArgs ea) {
		gb.stop = true;
		while (!gb.stopped) Sleep(1);
		gb.init();
		gb.stop = false;
	}
	
	void optionOpenRom(MenuItem mi, EventArgs ea) {
		gbt.pause();
		OpenFileDialog ofd = new OpenFileDialog;
		ofd.filter = "GameBoy files (*.gb)|*.gb";
		ofd.initialDirectory = Application.startupPath ~ "\\roms";
		if (ofd.showDialog() == DialogResult.OK) {
			gbt.resume();
			
			chdir(Application.startupPath);

			gb.unloadRom();
			
			gb.stop = true;
			while (!gb.stopped) Sleep(1);

			gb.loadRom(ofd.fileName);
			gb.init();
				
			gb.stop = false;
		} else {
			gbt.resume();
		}
	}

	void optionExit(MenuItem mi, EventArgs ea) {
		Application.exit();
	}


	private void initializeMainForm() {
		// Do not manually edit this block of code.
		//~Entice Designer 0.8.2.1 code begins here.
		//~DFL Form
		formBorderStyle = dfl.form.FormBorderStyle.FIXED_SINGLE;
		maximizeBox = false;
		startPosition = dfl.form.FormStartPosition.CENTER_SCREEN;
		text = "GameBoy";
		clientSize = dfl.drawing.Size(294, 273);
		//~DFL dfl.picturebox.PictureBox=pictureBox1
		pictureBox1 = new dfl.picturebox.PictureBox();
		pictureBox1.name = "pictureBox1";
		pictureBox1.dock = dfl.control.DockStyle.FILL;
		pictureBox1.bounds = dfl.base.Rect(0, 0, 294, 273);
		pictureBox1.parent = this;
		//~Entice Designer 0.8.2.1 code ends here.
	}

	JoyPAD.Key[uint] keyTranslator;
	
	void setKey(Keys skey, JoyPAD.Key gkey) {
		keyTranslator[cast(uint)skey] = gkey;
	}
	
	void initializeKeyTranslator() {
		setKey(Keys.UP   , JoyPAD.Key.UP);
		setKey(Keys.LEFT , JoyPAD.Key.LEFT);
		setKey(Keys.DOWN , JoyPAD.Key.DOWN);
		setKey(Keys.RIGHT, JoyPAD.Key.RIGHT);

		setKey(Keys.Z    , JoyPAD.Key.A);
		setKey(Keys.X    , JoyPAD.Key.B);
		setKey(Keys.SPACE, JoyPAD.Key.SELECT);
		setKey(Keys.ENTER, JoyPAD.Key.START);
	}
		
	bool preFilterMessage(inout Message m) {
		if (this.pictureBox1.handle != m.hWnd && this.handle != m.hWnd) return false;
		switch (m.msg) {
			case 256: // WM_KEYDOWN
			case 257: // WM_KEYUP
				if (m.msg == 257) {
					if (m.wParam == 27) Application.exit();
				}
				
				if (gb && gb.pad && m.wParam in keyTranslator) {					
					JoyPAD.Key key = keyTranslator[m.wParam];
					if (m.msg == 256) gb.pad.Press(key); else gb.pad.Release(key);
				}				
			break;
			default: break;
		}		
		return false;
	}
	
}

MainForm mainForm;
GameboyThread gbt;

class GameboyThread : Thread {
	GameBoy gb;
	
	override int run() {
		gb = new GameBoy(mainForm);

		gb.loadRom("ROMS\\TETRIS.GB");
		gb.init();

		gb.interpret();		
		
		return 0;
	}
}


int main()
{
	int result = 0;

	try {
		
		mainForm = new MainForm();
		
		(gbt = new GameboyThread()).start();
		
		Application.addMessageFilter(mainForm);
		Application.run(mainForm);
		
	} catch(Object o) {
		msgBox(o.toString(), "Fatal Error", MsgBoxButtons.OK, MsgBoxIcon.ERROR);

		result = 1;
	}

	return result;
}

