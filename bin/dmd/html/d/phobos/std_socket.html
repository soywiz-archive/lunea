<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.socket - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="../dmlogo.gif" width="270" height="53" border="0" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 1.0</p>


	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Phobos/StdSocket" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="../index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Wed Apr 23 23:16:40 2008
</div>
</div>



<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/1.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D ...</a></li>
	<li><a href="../lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bind.html" title="Function argument binding">std.bind</a></li>
	<li><a href="std_bitarray.html" title="Arrays of bits">std.bitarray</a></li>
	<li><a href="std_boxer.html" title="Box/unbox types">std.boxer</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std_intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_openrj.html" title="Basic database">std.openrj</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy threads">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_regexp.html" title="regular expressions">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_thread.html" title="Thread operations">std.thread</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
</div>

</div>
<div id="content">
    <h1>std.socket</h1>
    <!-- Generated by Ddoc from std\socket.d -->
<b>Notes:</b><br>
For Win32 systems, link with ws2_32.lib.
<br><br>
<b>Example:</b><br>
See /dmd/samples/d/listener.d.
<br><br>
<b>Authors:</b><br>
Christopher E. Miller
<br><br>

<dl><dt><big>class <u>SocketException</u>: object.Exception;
</big></dt>
<dd>Base exception thrown from a Socket.
<br><br>

<dl><dt><big>int <u>errorCode</u>;
</big></dt>
<dd>Platform-specific error code.
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>AddressFamily</u>;
</big></dt>
<dd>The communication domain used to resolve an address.
 
<br><br>

<dl><dt><big><u>UNSPEC</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>UNIX</u></big></dt>
<dd>local communication
<br><br>

</dd>
<dt><big><u>INET</u></big></dt>
<dd>internet protocol version 4
<br><br>

</dd>
<dt><big><u>IPX</u></big></dt>
<dd>novell <u>IPX</u>
<br><br>

</dd>
<dt><big><u>APPLETALK</u></big></dt>
<dd>appletalk
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>SocketType</u>;
</big></dt>
<dd>Communication semantics
 
<br><br>

<dl><dt><big><u>STREAM</u></big></dt>
<dd>sequenced, reliable, two-way communication-based byte streams
<br><br>

</dd>
<dt><big><u>DGRAM</u></big></dt>
<dd>connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order
<br><br>

</dd>
<dt><big><u>RAW</u></big></dt>
<dd>raw protocol access
<br><br>

</dd>
<dt><big><u>RDM</u></big></dt>
<dd>reliably-delivered message datagrams
<br><br>

</dd>
<dt><big><u>SEQPACKET</u></big></dt>
<dd>sequenced, reliable, two-way connection-based datagrams with a fixed maximum length
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>ProtocolType</u>;
</big></dt>
<dd>Protocol
 
<br><br>

<dl><dt><big><u>IP</u></big></dt>
<dd>internet protocol version 4
<br><br>

</dd>
<dt><big><u>ICMP</u></big></dt>
<dd>internet control message protocol
<br><br>

</dd>
<dt><big><u>IGMP</u></big></dt>
<dd>internet group management protocol
<br><br>

</dd>
<dt><big><u>GGP</u></big></dt>
<dd>gateway to gateway protocol
<br><br>

</dd>
<dt><big><u>TCP</u></big></dt>
<dd>transmission control protocol
<br><br>

</dd>
<dt><big><u>PUP</u></big></dt>
<dd>PARC universal packet protocol
<br><br>

</dd>
<dt><big><u>UDP</u></big></dt>
<dd>user datagram protocol
<br><br>

</dd>
<dt><big><u>IDP</u></big></dt>
<dd>Xerox NS protocol
<br><br>

</dd>
<dt><big><u>IPV6</u></big></dt>
<dd>internet protocol version 6
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Protocol</u>;
</big></dt>
<dd><u>Protocol</u> is a class for retrieving protocol information.
 
<br><br>

<dl><dt><big>ProtocolType <u>type</u>;
<br>string <u>name</u>;
<br>string[] <u>aliases</u>;
</big></dt>
<dd>These members are populated when one of the following functions are called without failure:
<br><br>

</dd>
<dt><big>bool <u>getProtocolByName</u>(char[] <i>name</i>);
</big></dt>
<dd>Returns <b>false</b> on failure 
<br><br>

</dd>
<dt><big>bool <u>getProtocolByType</u>(ProtocolType <i>type</i>);
</big></dt>
<dd>Returns <b>false</b> on failure 
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Service</u>;
</big></dt>
<dd><u>Service</u> is a class for retrieving service information.
 
<br><br>

<dl><dt><big>string <u>name</u>;
<br>string[] <u>aliases</u>;
<br>ushort <u>port</u>;
<br>string <u>protocolName</u>;
</big></dt>
<dd>These members are populated when one of the following functions are called without failure: 
<br><br>

</dd>
<dt><big>bool <u>getServiceByName</u>(char[] <i>name</i>, char[] <i>protocolName</i>);
<br>bool <u>getServiceByName</u>(char[] <i>name</i>);
<br>bool <u>getServiceByPort</u>(ushort <i>port</i>, char[] <i>protocolName</i>);
<br>bool <u>getServiceByPort</u>(ushort <i>port</i>);
</big></dt>
<dd>If a protocol <i>name</i> is omitted, any protocol will be matched.
<br><br>
<b>Returns:</b><br>
<b>false</b> on failure.
	 
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>HostException</u>: object.Exception;
</big></dt>
<dd>Base exception thrown from an InternetHost.
 
<br><br>

<dl><dt><big>int <u>errorCode</u>;
</big></dt>
<dd>Platform-specific error code.
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>InternetHost</u>;
</big></dt>
<dd><u>InternetHost</u> is a class for resolving IPv4 addresses.
 
<br><br>

<dl><dt><big>string <u>name</u>;
<br>string[] <u>aliases</u>;
<br>uint32_t[] <u>addrList</u>;
</big></dt>
<dd>These members are populated when one of the following functions are called without failure: 
<br><br>

</dd>
<dt><big>bool <u>getHostByName</u>(char[] <i>name</i>);
</big></dt>
<dd>Resolve host <i>name</i>. Returns <b>false</b> if unable to resolve.
	 
<br><br>

</dd>
<dt><big>bool <u>getHostByAddr</u>(uint <i>addr</i>);
</big></dt>
<dd>Resolve IPv4 address number. Returns <b>false</b> if unable to resolve.
	 
<br><br>

</dd>
<dt><big>bool <u>getHostByAddr</u>(char[] <i>addr</i>);
</big></dt>
<dd>Same as previous, but <i>addr</i> is an IPv4 address string in the
 dotted-decimal form <i>a.b.c.d</i>.
 Returns <b>false</b> if unable to resolve.
	 
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>AddressException</u>: object.Exception;
</big></dt>
<dd>Base exception thrown from an Address.
 
<br><br>

<dl></dl>
</dd>
<dt><big>class <u>Address</u>;
</big></dt>
<dd><u>Address</u> is an abstract class for representing a network addresses.
 
<br><br>

<dl><dt><big>AddressFamily <u>addressFamily</u>();
</big></dt>
<dd>Family of this address.
<br><br>

</dd>
<dt><big>char[] <u>toString</u>();
</big></dt>
<dd>Human readable string representing this address.
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>UnknownAddress</u>: std.socket.Address;
</big></dt>
<dd><br><br>
<dl></dl>
</dd>
<dt><big>class <u>InternetAddress</u>: std.socket.Address;
</big></dt>
<dd><u>InternetAddress</u> is a class that represents an IPv4 (internet protocol version
 4) address and port.
 
<br><br>

<dl><dt><big>const uint <u>ADDR_ANY</u>;
</big></dt>
<dd>Any IPv4 address number.
<br><br>

</dd>
<dt><big>const uint <u>ADDR_NONE</u>;
</big></dt>
<dd>An invalid IPv4 address number.
<br><br>

</dd>
<dt><big>const ushort <u>PORT_ANY</u>;
</big></dt>
<dd>Any IPv4 port number.
<br><br>

</dd>
<dt><big>AddressFamily <u>addressFamily</u>();
</big></dt>
<dd>Overridden to return AddressFamily.INET.
<br><br>

</dd>
<dt><big>ushort <u>port</u>();
</big></dt>
<dd>Returns the IPv4 <u>port</u> number.
<br><br>

</dd>
<dt><big>uint <u>addr</u>();
</big></dt>
<dd>Returns the IPv4 address number.
<br><br>

</dd>
<dt><big>this(string <i>addr</i>, ushort <i>port</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>char[] <i>addr</i></td>
<td>an IPv4 address string in the dotted-decimal form a.b.c.d,
          or a host name that will be resolved using an InternetHost
          object.</td></tr>
<tr><td>ushort <i>port</i></td>
<td>may be PORT_ANY as stated below.</td></tr>
</table><br>

</dd>
<dt><big>this(uint <i>addr</i>, ushort <i>port</i>);
<br>this(ushort <i>port</i>);
</big></dt>
<dd>Construct a new Address. <i>addr</i> may be ADDR_ANY (default) and <i>port</i> may
 be PORT_ANY, and the actual numbers may not be known until a connection
 is made.
	 
<br><br>

</dd>
<dt><big>char[] <u>toAddrString</u>();
</big></dt>
<dd>Human readable string representing the IPv4 address in dotted-decimal form.	
<br><br>

</dd>
<dt><big>char[] <u>toPortString</u>();
</big></dt>
<dd>Human readable string representing the IPv4 port.
<br><br>

</dd>
<dt><big>char[] <u>toString</u>();
</big></dt>
<dd>Human readable string representing the IPv4 address and port in the form <i>a.b.c.d:e</i>.
<br><br>

</dd>
<dt><big>static uint <u>parse</u>(char[] <i>addr</i>);
</big></dt>
<dd>Parse an IPv4 address string in the dotted-decimal form <i>a.b.c.d</i>
 and return the number.
 If the string is not a legitimate IPv4 address,
 ADDR_NONE is returned.
	 
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>SocketAcceptException</u>: std.socket.SocketException;
</big></dt>
<dd><br><br>
<dl></dl>
</dd>
<dt><big>enum <u>SocketShutdown</u>;
</big></dt>
<dd>How a socket is shutdown:
<br><br>

<dl><dt><big><u>RECEIVE</u></big></dt>
<dd>socket receives are disallowed
<br><br>

</dd>
<dt><big><u>SEND</u></big></dt>
<dd>socket sends are disallowed
<br><br>

</dd>
<dt><big><u>BOTH</u></big></dt>
<dd>both RECEIVE and SEND
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>SocketFlags</u>;
</big></dt>
<dd>Flags may be OR'ed together:
<br><br>

<dl><dt><big><u>NONE</u></big></dt>
<dd>no flags specified 
<br><br>

</dd>
<dt><big><u>OOB</u></big></dt>
<dd>out-of-band stream data
<br><br>

</dd>
<dt><big><u>PEEK</u></big></dt>
<dd>peek at incoming data without removing it from the queue, only for receiving
<br><br>

</dd>
<dt><big><u>DONTROUTE</u></big></dt>
<dd>data should not be subject to routing; this flag may be ignored. Only for sending
<br><br>

</dd>
<dt><big><u>NOSIGNAL</u></big></dt>
<dd>don't send SIGPIPE signal on socket write error and instead return EPIPE
<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>timeval</u>;
</big></dt>
<dd>Duration timeout value.
<br><br>

<dl><dt><big>int <u>seconds</u>;
</big></dt>
<dd>Number of <u>seconds</u>.
<br><br>

</dd>
<dt><big>int <u>microseconds</u>;
</big></dt>
<dd>Number of additional <u>microseconds</u>.
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>SocketSet</u>;
</big></dt>
<dd>A collection of sockets for use with Socket.select.
<br><br>

<dl><dt><big>this(uint <i>max</i>);
</big></dt>
<dd>Set the maximum amount of sockets that may be added.
<br><br>

</dd>
<dt><big>this();
</big></dt>
<dd>Uses the default maximum for the system.
<br><br>

</dd>
<dt><big>void <u>reset</u>();
</big></dt>
<dd>Reset the SocketSet so that there are 0 Sockets in the collection.	
<br><br>

</dd>
<dt><big>void <u>add</u>(Socket <i>s</i>);
</big></dt>
<dd>Add a Socket to the collection. Adding more than the maximum has dangerous side affects.
<br><br>

</dd>
<dt><big>void <u>remove</u>(Socket <i>s</i>);
</big></dt>
<dd>Remove this Socket from the collection.
<br><br>

</dd>
<dt><big>int <u>isSet</u>(Socket <i>s</i>);
</big></dt>
<dd>Returns nonzero if this Socket is in the collection.
<br><br>

</dd>
<dt><big>uint <u>max</u>();
</big></dt>
<dd>Return maximum amount of sockets that can be added, like FD_SETSIZE.
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>SocketOptionLevel</u>;
</big></dt>
<dd>The level at which a socket option is defined:
<br><br>

<dl><dt><big><u>SOCKET</u></big></dt>
<dd>socket level
<br><br>

</dd>
<dt><big><u>IP</u></big></dt>
<dd>internet protocol version 4 level
<br><br>

</dd>
<dt><big><u>ICMP</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>IGMP</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>GGP</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>TCP</u></big></dt>
<dd>transmission control protocol level
<br><br>

</dd>
<dt><big><u>PUP</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>UDP</u></big></dt>
<dd>user datagram protocol level
<br><br>

</dd>
<dt><big><u>IDP</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>IPV6</u></big></dt>
<dd>internet protocol version 6 level
<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>linger</u>;
</big></dt>
<dd>Linger information for use with SocketOption.LINGER.
<br><br>

<dl><dt><big>uint16_t <u>on</u>;
</big></dt>
<dd>Nonzero for <u>on</u>.
<br><br>

</dd>
<dt><big>uint16_t <u>time</u>;
</big></dt>
<dd>Linger <u>time</u>.
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>SocketOption</u>;
</big></dt>
<dd>Specifies a socket option:
<br><br>

<dl><dt><big><u>DEBUG</u></big></dt>
<dd>record debugging information
<br><br>

</dd>
<dt><big><u>BROADCAST</u></big></dt>
<dd>allow transmission of broadcast messages
<br><br>

</dd>
<dt><big><u>REUSEADDR</u></big></dt>
<dd>allow local reuse of address
<br><br>

</dd>
<dt><big><u>LINGER</u></big></dt>
<dd>linger on close if unsent data is present
<br><br>

</dd>
<dt><big><u>OOBINLINE</u></big></dt>
<dd>receive out-of-band data in band
<br><br>

</dd>
<dt><big><u>SNDBUF</u></big></dt>
<dd>send buffer size
<br><br>

</dd>
<dt><big><u>RCVBUF</u></big></dt>
<dd>receive buffer size
<br><br>

</dd>
<dt><big><u>DONTROUTE</u></big></dt>
<dd>do not route
<br><br>

</dd>
<dt><big><u>TCP_NODELAY</u></big></dt>
<dd>disable the Nagle algorithm for send coalescing
<br><br>

</dd>
<dt><big><u>IPV6_UNICAST_HOPS</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>IPV6_MULTICAST_IF</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>IPV6_MULTICAST_LOOP</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>IPV6_JOIN_GROUP</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>IPV6_LEAVE_GROUP</u></big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big>class <u>Socket</u>;
</big></dt>
<dd><u>Socket</u> is a class that creates a network communication endpoint using the
 Berkeley sockets interface.
 
<br><br>

<dl><dt><big>this(AddressFamily <i>af</i>, SocketType <i>type</i>, ProtocolType <i>protocol</i>);
<br>this(AddressFamily <i>af</i>, SocketType <i>type</i>);
<br>this(AddressFamily <i>af</i>, SocketType <i>type</i>, string <i>protocolName</i>);
</big></dt>
<dd>Create a blocking socket. If a single <i>protocol</i> <i>type</i> exists to support
 this socket <i>type</i> within the address family, the ProtocolType may be
 omitted.
	 
<br><br>

</dd>
<dt><big>socket_t <u>handle</u>();
</big></dt>
<dd>Get underlying socket <u>handle</u>.
<br><br>

</dd>
<dt><big>bool <u>blocking</u>();
<br>void <u>blocking</u>(bool <i>byes</i>);
</big></dt>
<dd>Get/set socket's <u>blocking</u> flag.
<br><br>
When a socket is <u>blocking</u>, calls to receive(), accept(), and send()
 will block and wait for data/action.
 A non-<u>blocking</u> socket will immediately return instead of <u>blocking</u>.
	 
<br><br>

</dd>
<dt><big>AddressFamily <u>addressFamily</u>();
</big></dt>
<dd>Get the socket's address family.	
<br><br>

</dd>
<dt><big>bool <u>isAlive</u>();
</big></dt>
<dd>Property that indicates if this is a valid, alive socket.
<br><br>

</dd>
<dt><big>void <u>bind</u>(Address <i>addr</i>);
</big></dt>
<dd>Associate a local address with this socket.
<br><br>

</dd>
<dt><big>void <u>connect</u>(Address <i>to</i>);
</big></dt>
<dd>Establish a connection. If the socket is blocking, <u>connect</u> waits for
 the connection <i>to</i> be made. If the socket is nonblocking, <u>connect</u>
 returns immediately and the connection attempt is still in progress.
	 
<br><br>

</dd>
<dt><big>void <u>listen</u>(int <i>backlog</i>);
</big></dt>
<dd>Listen for an incoming connection. bind must be called before you can
 <u>listen</u>. The <i>backlog</i> is a request of how many pending incoming
 connections are queued until accept'ed.
	 
<br><br>

</dd>
<dt><big>protected Socket <u>accepting</u>();
</big></dt>
<dd>Called by accept when a new Socket must be created for a new
 connection. To use a derived class, override this method and return an
 instance of your class. The returned Socket's handle must not be set;
 Socket has a protected constructor this() to use in this situation.
	 
<br><br>

</dd>
<dt><big>Socket <u>accept</u>();
</big></dt>
<dd>Accept an incoming connection. If the socket is blocking, <u>accept</u>
 waits for a connection request. Throws SocketAcceptException if unable
 to <u>accept</u>. See accepting for use with derived classes.
	 
<br><br>

</dd>
<dt><big>void <u>shutdown</u>(SocketShutdown <i>how</i>);
</big></dt>
<dd>Disables sends and/or receives.
<br><br>

</dd>
<dt><big>void <u>close</u>();
</big></dt>
<dd>Immediately drop any connections and release socket resources.
 Calling shutdown before <u>close</u> is recommended for connection-oriented
 sockets. The Socket object is no longer usable after <u>close</u>.
	 
<br><br>

</dd>
<dt><big>static char[] <u>hostName</u>();
</big></dt>
<dd>Returns the local machine's host name. Idea from mango.
<br><br>

</dd>
<dt><big>Address <u>remoteAddress</u>();
</big></dt>
<dd>Remote endpoint Address.
<br><br>

</dd>
<dt><big>Address <u>localAddress</u>();
</big></dt>
<dd>Local endpoint Address.
<br><br>

</dd>
<dt><big>const int <u>ERROR</u>;
</big></dt>
<dd>Send or receive error code.
<br><br>

</dd>
<dt><big>int <u>send</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>);
<br>int <u>send</u>(void[] <i>buf</i>);
</big></dt>
<dd>Send data on the connection. Returns the number of bytes actually
 sent, or ERROR on failure. If the socket is blocking and there is no
 buffer space left, <u>send</u> waits.
	 
<br><br>

</dd>
<dt><big>int <u>sendTo</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>, Address <i>to</i>);
<br>int <u>sendTo</u>(void[] <i>buf</i>, Address <i>to</i>);
<br>int <u>sendTo</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>);
<br>int <u>sendTo</u>(void[] <i>buf</i>);
</big></dt>
<dd>Send data <i>to</i> a specific destination Address. If the destination address is not specified, a connection must have been made and that address is used. If the socket is blocking and there is no buffer space left, <u>sendTo</u> waits.
	 
<br><br>

</dd>
<dt><big>int <u>receive</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>);
<br>int <u>receive</u>(void[] <i>buf</i>);
</big></dt>
<dd>Receive data on the connection. Returns the number of bytes actually
 received, 0 if the remote side has closed the connection, or ERROR on
 failure. If the socket is blocking, <u>receive</u> waits until there is data
 to be received.
	 
<br><br>

</dd>
<dt><big>int <u>receiveFrom</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>, out Address <i>from</i>);
<br>int <u>receiveFrom</u>(void[] <i>buf</i>, out Address <i>from</i>);
<br>int <u>receiveFrom</u>(void[] <i>buf</i>, SocketFlags <i>flags</i>);
<br>int <u>receiveFrom</u>(void[] <i>buf</i>);
</big></dt>
<dd>Receive data and get the remote endpoint Address.
 If the socket is blocking, <u>receiveFrom</u> waits until there is data to
 be received.
<br><br>
<b>Returns:</b><br>
the number of bytes actually received,
 0 if the remote side has closed the connection, or ERROR on failure.
	 
<br><br>

</dd>
<dt><big>int <u>getOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, void[] <i>result</i>);
</big></dt>
<dd>Get a socket <i>option</i>. Returns the number of bytes written to <i>result</i>.	
<br><br>

</dd>
<dt><big>int <u>getOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, out int <i>result</i>);
</big></dt>
<dd>Common case of getting integer and boolean options.	
<br><br>

</dd>
<dt><big>int <u>getOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, out linger <i>result</i>);
</big></dt>
<dd>Get the linger <i>option</i>.	
<br><br>

</dd>
<dt><big>void <u>setOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, int <i>value</i>);
</big></dt>
<dd>Common case for setting integer and boolean options.
<br><br>

</dd>
<dt><big>void <u>setOption</u>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, linger <i>value</i>);
</big></dt>
<dd>Set the linger <i>option</i>.
<br><br>

</dd>
<dt><big>static int <u>select</u>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>, timeval* <i>tv</i>);
<br>static int <u>select</u>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>, int <i>microseconds</i>);
<br>static int <u>select</u>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>);
</big></dt>
<dd>Wait for a socket to change status. A wait timeout timeval or int microseconds may be specified; if a timeout is not specified or the timeval is <b>null</b>, the maximum timeout is used. The timeval timeout has an unspecified value when <u>select</u> returns. Returns the number of sockets with status changes, 0 on timeout, or -1 on interruption. If the return value is greater than 0, the SocketSets are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.
	 
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>TcpSocket</u>: std.socket.Socket;
</big></dt>
<dd><u>TcpSocket</u> is a shortcut class for a TCP Socket.
<br><br>

<dl><dt><big>this(AddressFamily <i>family</i>);
</big></dt>
<dd>Constructs a blocking TCP Socket.
<br><br>

</dd>
<dt><big>this();
</big></dt>
<dd>Constructs a blocking TCP Socket.
<br><br>

</dd>
<dt><big>this(Address <i>connectTo</i>);
</big></dt>
<dd>Constructs a blocking TCP Socket and connects to an InternetAddress.
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>UdpSocket</u>: std.socket.Socket;
</big></dt>
<dd><u>UdpSocket</u> is a shortcut class for a UDP Socket.
<br><br>

<dl><dt><big>this(AddressFamily <i>family</i>);
</big></dt>
<dd>Constructs a blocking UDP Socket.
<br><br>

</dd>
<dt><big>this();
</big></dt>
<dd>Constructs a blocking UDP Socket.
<br><br>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
 
</div>


<div id="copyright">
Copyright &copy; 1999-2008 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/1.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

